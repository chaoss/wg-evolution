#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2019 CHAOSS
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     Aniruddha Karajgi <akarajgi0@gmail.com>
#

import matplotlib.pyplot as plt
from perceval.backends.core.github import GitHub
from perceval.backends.core.git import Git
from datetime import datetime
import argparse
import os
import sys

from fpdf import FPDF
import json

from implementations.code_df.conditions import Naive, PostfixExclude, DirExclude
from implementations.code_df.conditions import MasterInclude, EmptyExclude, MergeExclude

from implementations.code_df.code_changes_git import CodeChangesGit
from implementations.code_df.code_changes_lines_git import CodeChangesLinesGit

from implementations.code_df.reviews_github import ReviewsGitHub
from implementations.code_df.reviews_accepted_github import ReviewsAcceptedGitHub
from implementations.code_df.reviews_declined_github import ReviewsDeclinedGitHub
from implementations.code_df.reviews_duration_github import ReviewsDurationGitHub


COMMIT_CATEGORY = 'commit'
ISSUE_CATEGORY = 'issue'
PULL_REQUEST_CATEGORY = 'pull_request'

GITHUB_URI = "http://github.com/"
COMMIT_METRICS = \
            [
                CodeChangesGit,
                CodeChangesLinesGit
            ]

ISSUE_METRICS = []

PULLREQUEST_METRICS = \
            [
                ReviewsGitHub,
                ReviewsAcceptedGitHub,
                ReviewsDeclinedGitHub,
                ReviewsDurationGitHub
            ]

METRICS = \
    {
        COMMIT_CATEGORY: COMMIT_METRICS,
        ISSUE_CATEGORY: ISSUE_METRICS,
        PULL_REQUEST_CATEGORY: PULLREQUEST_METRICS
    }


def parse_args():
    parser = argparse.ArgumentParser(
        description="Analyze script argument parser"
    )

    parser.add_argument("-t", "--api-token",
                        default=None,
                        help="GitHub API token")

    parser.add_argument("-r", "--repo",
                        required=True,
                        help="GitHub repository, as 'owner/repo'")

    parser.add_argument("-s", "--since",
                        default=None,
                        help="Start date for item consideration. ('%%Y-%%m-%%d' format)")

    parser.add_argument("-u", "--until",
                        default=None,
                        help="End date for item consideration. ('%%Y-%%m-%%d' format)")

    parser.add_argument("-cat", "--categories",
                        default=[COMMIT_CATEGORY],
                        nargs='+',
                        choices=[COMMIT_CATEGORY, ISSUE_CATEGORY, PULL_REQUEST_CATEGORY],
                        help="Possible options: %(choices)s (any combination)")

    parser.add_argument("-c", "--conds",
                        default=[],
                        nargs='+',
                        choices=['MergeExclude', 'EmptyExclude', 'MasterInclude'],
                        help="Restrictions on which commits to include."
                        " Possible options: %(choices)s (any combinations)")

    parser.add_argument("-i", "--is-code",
                        default=['Naive'],
                        nargs='+',
                        choices=['Naive', 'PostfixExclude', 'DirExclude'],
                        help="Definition of Source Code."
                             "Possible options: %(choices)s (any combination)")

    parser.add_argument("-pf", "--postfixes-to-exclude",
                        default=['.md', 'README'],
                        nargs='+',
                        help="Files to be excluded based on their extension."
                        "Examples: .md, README")

    parser.add_argument("-de", "--dirs-to-exclude",
                        default=['tests', 'bin'],
                        nargs='+',
                        help="Files to be excluded based on their path."
                             "Examples: tests, bin, docs")

    parser.add_argument("-p", "--period",
                        default='M',
                        help="period for time-series: 'M', 'W', 'D', etc."
                             "Any valid pandas Period frequency")

    parser.add_argument("-o", "--output-formats",
                        default=['json'],
                        nargs='+',
                        choices=['json', 'pdf', 'images'],
                        help="Possible options: %(choices)s (any combination)")
    return parser.parse_args()


def generate_output(results, output_formats=['json'], write_to='results_dir'):
    """
    Generate output based on results in different format.

    Output format:
    <write_to>
        - report.pdf
        - report.json
        - images
            - metric_1_name.png
            - metric_2_name.png
            - metric_3_name.png
    """

    if not os.path.exists(write_to):
        os.mkdir(write_to)

    generate_options = {
        'json': generate_json,
        'pdf': generate_pdf,
        'images': generate_images
    }

    for output_format in output_formats:
        generate_options[output_format](results, write_to)


def generate_images(results, write_to='results_dir'):
    if not os.path.exists(write_to + '/images'):
        os.mkdir(write_to + '/images')

    for category, results_ in results.items():
        for result in results_:
            result['metric'].plot_time_series()
            plt.savefig(write_to + '/images/' + "_".join(str(result['metric']).split()) + '.png')


def generate_json(results, write_to='results_dir'):
    """
    Generate a json file with results of metric computation,
    with each result on a new line.

    Creates write_to/report.json

    Format:
    {'category': 'commit', 'metric': <metric1>, 'value': <metric1_val>}
    {'category': 'commit', 'metric': <metric2>, 'value': <metric2_val>}
    {'category': 'issue', 'metric': <metric3>, 'value': <metric3_val>}
    ..
    .
    """

    with open(write_to + '/report.json', 'w') as json_file:
        for category, results_ in results.items():
            for result in results_:
                json.dump({
                            'category': category,
                            'metric': str(result['metric']),
                            'value': str(result['value'])}, json_file)
                json_file.write('\n')


def generate_pdf(results, write_to='results_dir'):
    """
    Generates a pdf report with results of the compute
    method as well as an image of the resultant plot.

    Creates write_to/report.pdf
    """

    pdf = FPDF('P', 'mm', 'A4')
    pdf.set_font('Arial', 'B', 50)
    pdf.set_margins(left=20, top=20, right=-1)

    pdf.add_page()
    pdf.cell(w=100, h=100, txt="Metric Report", border=0, ln=2)

    pdf.set_font('Arial', 'B', 25)
    generate_images(results, write_to)
    for category, results_ in results.items():
        for result in results_:
            pdf.add_page()
            pdf.cell(w=100, h=10, txt=str(result['metric']), border=0, ln=1)
            pdf.ln()

            txt = \
                """
                The value of the metric is:\n
                {}. \n
                """.format(result['value'])
            pdf.set_font('Arial', style='', size=16)
            pdf.multi_cell(w=0, h=3, txt=txt)
            pdf.image(write_to + '/images/' + "_".join(str(result['metric']).split()) + '.png', w=200)

    pdf.output(write_to + '/report.pdf', 'F')


def run_metrics(items, categories=[COMMIT_CATEGORY], date_range=(None, None),
                is_code=[Naive()], conds=[], period='M'):
    """
    Calculate values of metrics on the given data (items).
    Returns results.
    """

    results = {
        COMMIT_CATEGORY: [],
        ISSUE_CATEGORY: [],
        PULL_REQUEST_CATEGORY: []
    }

    for category in categories:
        for metric in METRICS[category]:
            if category == COMMIT_CATEGORY:
                metric_obj = metric(items[category], date_range,
                                    is_code, conds)
            else:
                metric_obj = metric(items[category], date_range)

            result = {
                        'metric': metric_obj,
                        'value': metric_obj.compute(),
                    }

            results[category].append(result)

    return results


def fetch_data(owner, repository, api_token=None, categories=[COMMIT_CATEGORY]):
    """
    Calls git or github backend, depending on the category of data.
    """

    data = {
        COMMIT_CATEGORY: [],
        ISSUE_CATEGORY: [],
        PULL_REQUEST_CATEGORY: []
    }

    for category in categories:
        if category == COMMIT_CATEGORY:
            repo_uri = GITHUB_URI + owner + '/' + repository + '.git'
            git = Git(uri=repo_uri, gitpath="tmp")
            items = list(git.fetch(category=category))

        else:
            github = GitHub(owner=owner, repository=repository,
                            api_token=api_token)
            items = list(github.fetch(category=category))

        data[category] = items

    data['issue'] = [item for item in data['issue'] if 'pull_request' not in item]
    return data


def main():

    args = parse_args()

    owner, repo = args.repo.split('/')
    date_range = (None, None)

    # date
    if args.since:
        date_range[0] = datetime.strptime(args.since, "%Y-%m-%d")
    if args.until:
        date_range[1] = datetime.strptime(args.until, "%Y-%m-%d")

    # conds parsing
    conds_options = {
        'MergeExclude': MergeExclude(),
        'EmptyExclude': EmptyExclude(),
        'MasterInclude': MasterInclude()
    }

    conds = [conds_options[option] for option in args.conds]

    # is_code parsing
    is_code_options = {
        'Naive': Naive(),
        'PostfixExclude': PostfixExclude(args.postfixes_to_exclude),
        'DirExclude': DirExclude(args.dirs_to_exclude)
    }

    is_code = [is_code_options[option] for option in args.is_code]

    items = fetch_data(owner, repo, args.api_token, args.categories)

    results = \
        run_metrics(
                        items, args.categories,
                        date_range=date_range, is_code=is_code,
                        conds=conds, period=args.period
                    )

    generate_output(results, args.output_formats)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        s = "\n\nReceived Ctrl-C or other break signal. Exiting.\n"
        sys.stderr.write(s)
        sys.exit(0)
